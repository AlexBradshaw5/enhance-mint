<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Uploaded Image</title>
    <style>
        #canvasContainer {
            position: relative;
            display: inline-block;
            height: 300px;
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
        }
        .controls {
            display: block;
            margin-top: 10px;
        }
        label {
            font-size: 18px;
            display: inline-block;
            margin-bottom: 5px;
        }
        input[type="range"] {
            display: inline-block;
            width: 300px;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <h1>Uploaded Image</h1>
    <div id="canvasContainer">
        <canvas id="imageCanvas"></canvas>
        <canvas id="drawCanvas"></canvas>
    </div>
    <div class="controls">
        <label for="brushSize">Brush size: </label>
        <input type="range" id="brushSize" name="brushSize" min="1" max="50" value="5">
        <button id="undo">Undo</button>
        <button id="exportPNG">Export as PNG</button>
    </div>
    <br>
    <a href="{{ url_for('index') }}">Upload another image</a>

    <script>
        const imageCanvas = document.getElementById('imageCanvas');
        const drawCanvas = document.getElementById('drawCanvas');
        const imageCtx = imageCanvas.getContext('2d');
        const drawCtx = drawCanvas.getContext('2d');
        const brushSizeInput = document.getElementById('brushSize');
        const undoButton = document.getElementById('undo');

        const image = new Image();
        image.src = "{{ url_for('serve_image', filename=filename) }}";
        image.onload = function () {
            imageCanvas.width = image.width;
            imageCanvas.height = image.height;
            drawCanvas.width = image.width;
            drawCanvas.height = image.height;
            imageCtx.drawImage(image, 0, 0);
        };

        let drawing = false;
        let paths = [];
        let currentPath = [];

        drawCanvas.addEventListener('mousedown', function (event) {
            drawing = true;
            drawCtx.lineWidth = brushSizeInput.value;
            drawCtx.beginPath();
            const xPos = event.clientX - drawCanvas.getBoundingClientRect().left;
            const yPos = event.clientY - drawCanvas.getBoundingClientRect().top;
            drawCtx.moveTo(xPos, yPos);
            currentPath.push({ x: xPos, y: yPos, size: drawCtx.lineWidth });
        });

        drawCanvas.addEventListener('mousemove', function (event) {
            if (!drawing) return;
            const xPos = event.clientX - drawCanvas.getBoundingClientRect().left;
            const yPos = event.clientY - drawCanvas.getBoundingClientRect().top;
            drawCtx.lineWidth = brushSizeInput.value;
            drawCtx.lineTo(xPos, yPos);
            drawCtx.stroke();
            currentPath.push({ x: xPos, y: yPos, size: drawCtx.lineWidth });
        });

        drawCanvas.addEventListener('mouseup', function () {
            if (drawing) {
                paths.push(currentPath);
                currentPath = [];
            }
            drawing = false;
        });

        drawCanvas.addEventListener('mouseout', function () {
            drawing = false;
        });

        undoButton.addEventListener('click', function () {
            paths.pop();
            redraw();
        });

        brushSizeInput.addEventListener('input', function () {
        drawCtx.lineWidth = brushSizeInput.value;
        });

        function redraw() {
            drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
            drawCtx.lineCap = 'round';

            for (const path of paths) {
                drawCtx.beginPath();
                const startPoint = path[0];
                drawCtx.moveTo(startPoint.x, startPoint.y);
                drawCtx.lineWidth = startPoint.size;

                for (const point of path.slice(1)) {
                    drawCtx.lineTo(point.x, point.y);
                    drawCtx.lineWidth = point.size;
                    drawCtx.stroke();
                }
            }
        }

        function saveImage(canvas, imgType, imgName) {
            const imageData = canvas.toDataURL(imgType);
            const xhr = new XMLHttpRequest();
            xhr.open('POST', '/export', true);
            xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
            xhr.send('imgData=' + encodeURIComponent(imageData) + '&imgType=' + encodeURIComponent(imgType) + '&imgName=' + encodeURIComponent(imgName));
        }

        function prepareCanvasForExport(canvas) {
            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = canvas.width;
            exportCanvas.height = canvas.height;
            const exportCtx = exportCanvas.getContext('2d');

            // Fill the background with black color
            exportCtx.fillStyle = 'black';
            exportCtx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);

            // Draw the original canvas content with inverted colors
            exportCtx.globalCompositeOperation = 'xor';
            exportCtx.drawImage(canvas, 0, 0);

            return exportCanvas;
        }

        const exportPNGButton = document.getElementById('exportPNG');

        exportPNGButton.addEventListener('click', function () {
            saveImage(imageCanvas, 'image/png', 'original_image.png');
            const preparedCanvas = prepareCanvasForExport(drawCanvas);
            saveImage(preparedCanvas, 'image/png', 'canvas_drawing.png');
        });

        </script>
    </body>
</html>

